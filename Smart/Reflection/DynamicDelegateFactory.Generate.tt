// <auto-generated />
namespace Smart.Reflection
{
    using System;
    using System.Reflection;

    public sealed partial class DynamicDelegateFactory
    {
<# for (var i = 0; i <= 16; i++) { #>
        private static readonly Type[] Factory<#= i #>ParameterTypes = { typeof(object)<# for (var j = 0; j < i; j++) { #>, typeof(object)<# } #> };

<# } #>
<# for (var i = 0; i <= 16; i++) { #>
        private static readonly Type Factory<#= i #>Type = typeof(Func<object<# for (var j = 0; j < i; j++) { #>, object<# } #>>);

<# } #>
<# for (var i = 0; i <= 16; i++) { #>
        public Func<object<# for (var j = 0; j < i; j++) { #>, object<# } #>> CreateFactory<#= i #>(ConstructorInfo ci)
        {
            if (ci == null)
            {
                throw new ArgumentNullException(nameof(ci));
            }

            return (Func<object<# for (var j = 0; j < i; j++) { #>, object<# } #>>)factoryDelegateCache
                .GetOrAdd(ci, x => CreateFactoryInternal(x, Factory<#= i #>ParameterTypes, Factory<#= i #>Type));
        }

<# } #>
<# for (var i = 0; i <= 16; i++) { #>
        public Func<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T> CreateFactory<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T>()
        {
            var ci = typeof(T).GetConstructor(<# if (i == 0) { #>Type.EmptyTypes<# } else { #>new[] { typeof(TP1)<# for (var j = 1; j < i; j++) { #>, typeof(TP<#= j + 1 #>)<# } #> }<# } #>);
            if (ci == null)
            {
                throw new ArgumentException("Constructor type parameter is invalid.");
            }

            return (Func<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T>)typedFactoryCache
                .GetOrAdd(ci, x=> CreateFactoryInternal(
                    ci,
                    typeof(T),
                    new[] { typeof(T)<# for (var j = 1; j <= i; j++) { #>, typeof(TP<#= j #>)<# } #> },
                    typeof(Func<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T>)));
        }

<# } #>
    }
}
