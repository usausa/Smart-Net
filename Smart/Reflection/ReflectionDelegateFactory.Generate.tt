// <auto-generated />
namespace Smart.Reflection
{
    using System;
    using System.Reflection;

    public sealed partial class ReflectionDelegateFactory
    {
<# for (var i = 1; i <= 16; i++) { #>
        public Func<object<# for (var j = 0; j < i; j++) { #>, object<# } #>> CreateFactory<#= i #>(ConstructorInfo ci)
        {
            if (ci == null)
            {
                throw new ArgumentNullException(nameof(ci));
            }

            if (ci.GetParameters().Length != <#= i #>)
            {
                throw new ArgumentException($"Constructor parameter length is invalid. length={ci.GetParameters().Length}", nameof(ci));
            }

            return (p1<# for (var j = 1; j < i; j++) { #>, p<#= j + 1 #><# } #>) => ci.Invoke(new[] { p1<# for (var j = 1; j < i; j++) { #>, p<#= j + 1 #><# } #> });
        }

<# } #>
<# for (var i = 1; i <= 16; i++) { #>
        public Func<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T> CreateFactory<<# for (var j = 1; j <= i; j++) { #>TP<#= j #>, <# } #>T>()
        {
            var ci = typeof(T).GetConstructor(new[] { typeof(TP1)<# for (var j = 1; j < i; j++) { #>, typeof(TP<#= j + 1 #>)<# } #> });
            if (ci == null)
            {
                throw new ArgumentException("Constructor type parameter is invalid.");
            }

            return (p1<# for (var j = 1; j < i; j++) { #>, p<#= j + 1 #><# } #>) => (T)ci.Invoke(new object[] { p1<# for (var j = 1; j < i; j++) { #>, p<#= j + 1 #><# } #> });
        }

<# } #>
    }
}
